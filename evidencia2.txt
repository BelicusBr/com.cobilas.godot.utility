a014449 - 2025-11-27: #[7.5.1] Correction made to the `Rect2D.HasPoint` function due to an incorrect pivot calculation that resulted in incorrect detection. (BelicusBr)
diff --git a/src/com.cobilas.godot.utility/Godot/Camera2D_GD_CB_Extension.cs b/src/com.cobilas.godot.utility/Godot/Camera2D_GD_CB_Extension.cs
index b4d5419..eb94342 100644
--- a/src/com.cobilas.godot.utility/Godot/Camera2D_GD_CB_Extension.cs
+++ b/src/com.cobilas.godot.utility/Godot/Camera2D_GD_CB_Extension.cs
@@ -10,19 +10,17 @@ public static class Camera2D_GD_CB_Extension {
     /// <returns>Return a two-dimensional vector with the result of converting the screen position to a position in the 2D world.</returns>
     public static Vector2D ScreenToWorldPoint(this Camera2D C, Vector2D mousePosition) {
         Vector2D size = (Vector2D)Screen.CurrentResolution * C.Zoom;
-        Rect2 rect = C.AnchorMode == Camera2D.AnchorModeEnum.DragCenter ? new(C.Position - size * .5f, size) : new(C.Position, size);
+        Vector2D camPosition = C.Position + C.Offset;
+		Rect2 rect = C.AnchorMode == Camera2D.AnchorModeEnum.DragCenter ? new(camPosition - size * .5f, size) : new(camPosition, size);
         return mousePosition * C.Zoom + Vector2D.Right * rect.Left() + Vector2D.Down * rect.Top();
     }
-    /// <summary>Converts a position in the 2D world to a position on the screen.</summary>
-    /// <param name="C">The 2D camera that will be used for conversion.</param>
-    /// <param name="position">The position of the 2D world that will be converted.</param>
-    /// <returns>Returns a two-dimensional vector with the result of converting the 2D world position to a screen position.</returns>
-    public static Vector2D WorldToScreenPoint(this Camera2D C, Vector2D position)
-        => (position - (C.AnchorMode == Camera2D.AnchorModeEnum.DragCenter?
-        C.Position - (Vector2D)Screen.CurrentResolution * C.Zoom * .5f : (Vector2D)C.Position)) / C.Zoom;
-        // Vector2D rect = C.Position;
-        // if (C.AnchorMode == Camera2D.AnchorModeEnum.DragCenter)
-        //     rect = C.Position - (Vector2D)Screen.CurrentResolution * C.Zoom * .5f;
-        // return position - rect;
-
+	/// <summary>Converts a position in the 2D world to a position on the screen.</summary>
+	/// <param name="C">The 2D camera that will be used for conversion.</param>
+	/// <param name="position">The position of the 2D world that will be converted.</param>
+	/// <returns>Returns a two-dimensional vector with the result of converting the 2D world position to a screen position.</returns>
+	public static Vector2D WorldToScreenPoint(this Camera2D C, Vector2D position) {
+		Vector2D camPosition = C.Position + C.Offset;
+		return (position - (C.AnchorMode == Camera2D.AnchorModeEnum.DragCenter ?
+			camPosition - (Vector2D)Screen.CurrentResolution * C.Zoom * .5f : camPosition)) / C.Zoom;
+	}
 }
\ No newline at end of file
diff --git a/src/com.cobilas.godot.utility/Godot/Control_GD_CB_Extension.cs b/src/com.cobilas.godot.utility/Godot/Control_GD_CB_Extension.cs
index 72d427a..d69544b 100644
--- a/src/com.cobilas.godot.utility/Godot/Control_GD_CB_Extension.cs
+++ b/src/com.cobilas.godot.utility/Godot/Control_GD_CB_Extension.cs
@@ -20,7 +20,7 @@ public static class Control_GD_CB_Extension {
     public static Rect2D GetRect2D(this Control? ctl)
         => ctl switch {
             null => throw new ArgumentNullException(nameof(ctl)),
-            _ => DoNotGetRect2Dposition(ctl).SetPosition(ctl.RectPosition),
+            _ => DoNotGetRect2Dposition(ctl).SetPosition(ctl.RectPosition + ctl.RectPivotOffset),
         };
     /// <summary>
     /// Sets the properties of the <seealso cref="Control"/> based on a <seealso cref="Rect2D"/>.
@@ -30,7 +30,7 @@ public static class Control_GD_CB_Extension {
     /// <exception cref="ArgumentNullException">Thrown when <seealso cref="Control"/> is null</exception>
     public static void SetRect2D(this Control? ctl, Rect2D rect) {
         if (ctl is null) throw new ArgumentNullException(nameof(ctl));
-        ctl.RectPosition = rect.Position;
+        ctl.RectPosition = rect.Position - ctl.RectPivotOffset;
         SetNoRect2DPosition(ctl, rect);
     }
     /// <summary>
@@ -42,7 +42,7 @@ public static class Control_GD_CB_Extension {
     public static Rect2D GetGlobalRect2D(this Control? ctl)
         => ctl switch {
             null => throw new ArgumentNullException(nameof(ctl)),
-            _ => DoNotGetRect2Dposition(ctl).SetPosition(ctl.RectGlobalPosition),
+            _ => DoNotGetRect2Dposition(ctl).SetPosition(ctl.RectGlobalPosition + ctl.RectPivotOffset),
         };
     /// <summary>
     /// Sets the properties of the <seealso cref="Control"/> based on a <seealso cref="Rect2D"/>, using global coordinates.
@@ -52,7 +52,7 @@ public static class Control_GD_CB_Extension {
     /// <exception cref="ArgumentNullException">Thrown when <seealso cref="Control"/> is null</exception>
     public static void SetGlobalRect2D(this Control? ctl, Rect2D rect) {
         if (ctl is null) throw new ArgumentNullException(nameof(ctl));
-        ctl.RectGlobalPosition = rect.Position;
+        ctl.RectGlobalPosition = rect.Position - ctl.RectPivotOffset;
         SetNoRect2DPosition(ctl, rect);
     }
 
diff --git a/src/com.cobilas.godot.utility/Godot/Sprite_CB_GB_Extension.cs b/src/com.cobilas.godot.utility/Godot/Sprite_CB_GB_Extension.cs
index 67e3f31..b2e9693 100644
--- a/src/com.cobilas.godot.utility/Godot/Sprite_CB_GB_Extension.cs
+++ b/src/com.cobilas.godot.utility/Godot/Sprite_CB_GB_Extension.cs
@@ -94,5 +94,5 @@ public static class Sprite_CB_GB_Extension {
             .SetMinSize(Vector2D.Zero)
             .SetRotation(ctl.RotationDegrees)
             .SetScale(ctl.Scale)
-            .SetPivot(ctl.Offset);
+            .SetPivot((ctl.Centered ? GetTextureSize(ctl) * .5f : Vector2D.Zero) + ctl.Offset);
 }
diff --git a/src/com.cobilas.godot.utility/GodotEngine.Utility/InternalGizmos.cs b/src/com.cobilas.godot.utility/GodotEngine.Utility/InternalGizmos.cs
index 811c045..5486c58 100644
--- a/src/com.cobilas.godot.utility/GodotEngine.Utility/InternalGizmos.cs
+++ b/src/com.cobilas.godot.utility/GodotEngine.Utility/InternalGizmos.cs
@@ -14,6 +14,7 @@ internal class InternalGizmos : CanvasLayer {
 
     private static InternalGizmos? gizmos = null;
     private static event Action? drawFunc = null;
+    private static readonly Dictionary<Color, ColorTarget> colors = [];
 
     /// <summary>Sets the Color of the gizmos that are drawn next.</summary>
     /// <value>Returns or sets the color of the next gizmo.</value>
@@ -57,7 +58,7 @@ internal class InternalGizmos : CanvasLayer {
 
     private void DrawGizmos() {
         drawFunc?.Invoke();
-        drawFunc = null;
+        //drawFunc = null;
     }
     /// <summary>
     /// Draws a line from a 2D point to another, with a given color and width. It can
@@ -70,7 +71,7 @@ internal class InternalGizmos : CanvasLayer {
     /// <param name="end">The end of the line.</param>
     /// <param name="width">The thickness of the line.</param>
     internal static void DrawLine(Vector2 start, Vector2 end, float width)
-        => drawFunc += () => gizmos!.canvasItem!.DrawLine(start, end, Color, width);
+        => SetDrawFunc(Color, (c) => gizmos!.canvasItem!.DrawLine(start, end, c, width));
     /// <summary>
     /// Draws a line from a 2D point to another, with a given color and width. It can
     /// be optionally antialiased. See also <seealso cref="CanvasItem.DrawMultiline(Vector2[], Color, float, bool)"/>
@@ -88,7 +89,7 @@ internal class InternalGizmos : CanvasLayer {
     /// </summary>
     /// <param name="rect">The dimensions of the rectangle.</param>
     internal static void DrawRect(Rect2 rect)
-        => drawFunc += () => gizmos!.canvasItem!.DrawRect(rect, Color);
+        => SetDrawFunc(Color, (c) => gizmos!.canvasItem!.DrawRect(rect, c));
     /// <summary>
     /// Draw a rectangle of a skeletonized body.
     /// <para>Note: Due to how it works, built-in antialiasing will not look correct for translucent polygons and may not work on certain platforms. As a workaround, install the <a href="https://github.com/godot-extended-libraries/godot-antialiased-line2d">Antialiased Line2D</a> add-on then create an AntialiasedPolygon2D node. That node relies on a texture with custom mipmaps to perform antialiasing.</para>
@@ -96,7 +97,7 @@ internal class InternalGizmos : CanvasLayer {
     /// <param name="rect">The dimensions of the rectangle.</param>
     /// <param name="width">The thickness of the line.</param>
     internal static void DrawWireRect(Rect2 rect, float width)
-        => drawFunc += () => gizmos!.canvasItem!.DrawRect(rect, Color, false, width);
+        => SetDrawFunc(Color, (c) => gizmos!.canvasItem!.DrawRect(rect, c, false, width));
     /// <summary>
     /// Draw a rectangle of a skeletonized body.
     /// <para>Note: Due to how it works, built-in antialiasing will not look correct for translucent polygons and may not work on certain platforms. As a workaround, install the <a href="https://github.com/godot-extended-libraries/godot-antialiased-line2d">Antialiased Line2D</a> add-on then create an AntialiasedPolygon2D node. That node relies on a texture with custom mipmaps to perform antialiasing.</para>
@@ -110,7 +111,7 @@ internal class InternalGizmos : CanvasLayer {
     /// <param name="position">The central position of the circle.</param>
     /// <param name="radius">The radius of the circle.</param>
     internal static void DrawCircle(Vector2 position, float radius)
-        => drawFunc += () => gizmos!.canvasItem!.DrawCircle(position, radius, Color);
+        => SetDrawFunc(Color, (c) => gizmos!.canvasItem!.DrawCircle(position, radius, c));
     /// <summary>
     /// <para>Draws multiple disconnected lines with a uniform <c>color</c>. When drawing large amounts of lines, this is faster than using individual <see cref="M:Godot.CanvasItem.DrawLine(Godot.Vector2,Godot.Vector2,Godot.Color,System.Single,System.Boolean)" /> calls. To draw interconnected lines, use <see cref="M:Godot.CanvasItem.DrawPolyline(Godot.Vector2[],Godot.Color,System.Single,System.Boolean)" /> instead.</para>
     /// <para>Note: <c>width</c> and <c>antialiased</c> are currently not implemented and have no effect. As a workaround, install the <a href="https://github.com/godot-extended-libraries/godot-antialiased-line2d">Antialiased Line2D</a> add-on then create an AntialiasedLine2D node. That node relies on a texture with custom mipmaps to perform antialiasing. 2D batching is also still supported with those antialiased lines.</para>
@@ -118,7 +119,7 @@ internal class InternalGizmos : CanvasLayer {
     /// <param name="points">The points that form the line.</param>
     /// <param name="width">The thickness of the line.</param>
     internal static void DrawMultiline(Vector2[] points, float width)
-        => drawFunc += () => gizmos!.canvasItem!.DrawMultiline(points, Color, width);
+        => SetDrawFunc(Color, (c) => gizmos!.canvasItem!.DrawMultiline(points, c, width));
     /// <summary>
     /// <para>Draws multiple disconnected lines with a uniform <c>color</c>. When drawing large amounts of lines, this is faster than using individual <see cref="M:Godot.CanvasItem.DrawLine(Godot.Vector2,Godot.Vector2,Godot.Color,System.Single,System.Boolean)" /> calls. To draw interconnected lines, use <see cref="M:Godot.CanvasItem.DrawPolyline(Godot.Vector2[],Godot.Color,System.Single,System.Boolean)" /> instead.</para>
     /// <para>Note: <c>width</c> and <c>antialiased</c> are currently not implemented and have no effect. As a workaround, install the <a href="https://github.com/godot-extended-libraries/godot-antialiased-line2d">Antialiased Line2D</a> add-on then create an AntialiasedLine2D node. That node relies on a texture with custom mipmaps to perform antialiasing. 2D batching is also still supported with those antialiased lines.</para>
@@ -152,7 +153,7 @@ internal class InternalGizmos : CanvasLayer {
     /// </param>
     /// <param name="width">The thickness of the line.</param>
     internal static void DrawArc(Vector2 center, float radius, float startAngle, float endAngle, int pointCount, float width)
-        => drawFunc += () => gizmos!.canvasItem!.DrawArc(center, radius, startAngle, endAngle, pointCount, Color, width);
+        => SetDrawFunc(Color, (c) => gizmos!.canvasItem!.DrawArc(center, radius, startAngle, endAngle, pointCount, c, width));
     /// <summary>
     /// <para>Draws a unfilled arc between the given angles. The larger the value of <c>point_count</c>, the smoother the curve. See also <see cref="M:Godot.CanvasItem.DrawCircle(Godot.Vector2,System.Single,Godot.Color)" />.</para>
     /// <para>Note: Line drawing is not accelerated by batching if <c>antialiased</c> is <c>true</c>.</para>
@@ -175,16 +176,41 @@ internal class InternalGizmos : CanvasLayer {
     /// <param name="normalMap">The texture normal map.</param>
     /// <param name="transform">If the parameter is null, then the default value is Transform2D.Identity</param>
     internal static void DrawMesh(Mesh mesh, Texture texture, Texture? normalMap = null, Transform2D? transform = null)
-        => drawFunc += () => gizmos!.canvasItem!.DrawMesh(mesh, texture, normalMap, transform, Color);
+        => SetDrawFunc(Color, (c) => gizmos!.canvasItem!.DrawMesh(mesh, texture, normalMap, transform, c));
     /// <summary>
     /// <para>Draws a texture at a given position.</para>
     /// </summary>
     internal static void DrawTexture(Texture texture, Vector2 position, Texture? normalMap = null)
-        => drawFunc += () => gizmos!.canvasItem!.DrawTexture(texture, position, Color, normalMap);
+        => SetDrawFunc(Color, (c) => gizmos!.canvasItem!.DrawTexture(texture, position, c, normalMap));
 
     /// <summary>
     /// <para>Draws a textured rectangle at a given position, optionally modulated by a color. If <c>transpose</c> is <c>true</c>, the texture will have its X and Y coordinates swapped.</para>
     /// </summary>
     internal static void DrawTextureRect(Texture texture, Rect2 rect, bool tile, bool transpose = false, Texture? normalMap = null)
-        => drawFunc += () => gizmos!.canvasItem!.DrawTextureRect(texture, rect, tile, Color, transpose, normalMap);
+        => SetDrawFunc(Color, (c) => gizmos!.canvasItem!.DrawTextureRect(texture, rect, tile, c, transpose, normalMap));
+
+    private static void SetDrawFunc(Color colorTarget, Action<Color> func) {
+        if (colors.TryGetValue(colorTarget, out ColorTarget target)) target.DrawFunc += func;
+        else {
+            target = new(colorTarget);
+			target.DrawFunc += func;
+            drawFunc += target.Invok;
+            colors.Add(colorTarget, target);
+		}
+    }
+
+	private sealed class ColorTarget {
+        public event Action<Color>? DrawFunc;
+
+        private Color myColor { get; set; }
+
+		public ColorTarget(Color color) {
+            myColor = color;
+		}
+
+		public void Invok() {
+            DrawFunc?.Invoke(myColor);
+            DrawFunc = null;
+        }
+	}
 }
\ No newline at end of file
diff --git a/src/com.cobilas.godot.utility/GodotEngine.Utility/Rect2D.cs b/src/com.cobilas.godot.utility/GodotEngine.Utility/Rect2D.cs
index a6626df..043dedc 100644
--- a/src/com.cobilas.godot.utility/GodotEngine.Utility/Rect2D.cs
+++ b/src/com.cobilas.godot.utility/GodotEngine.Utility/Rect2D.cs
@@ -4,7 +4,6 @@ using System.Globalization;
 using Cobilas.GodotEngine.Utility.Numerics;
 
 namespace Cobilas.GodotEngine.Utility;
-
 /// <summary>Represents a 2D rectangle with advanced properties for geometric transformations.</summary>
 /// <remarks>
 /// This structure extends the functionality of a traditional rectangle, including
@@ -245,19 +244,19 @@ public struct Rect2D(float x,
     /// <param name="point">The point to be checked.</param>
     /// <returns>true if the point is inside the rectangle; otherwise, false.</returns>
     public readonly bool HasPoint(Vector2D point) {
-        Vector2D position = Position;
-        Quaternion quaternion = Quaternion.ToQuaternion(Vector3D.Forward * RadianRotation);
-        Vector2D dirx = quaternion.GenerateDirectionRight() * SizeScale.x;
-        Vector2D diry = quaternion.GenerateDirectionDown() * SizeScale.y;
-        Vector2D pivx = quaternion.GenerateDirectionLeft() * PivotScale.x;
-        Vector2D pivy = quaternion.GenerateDirectionUp() * PivotScale.y;
-        position += Pivot + pivx + pivy;
-        Vector2D px = position + dirx;
-        Vector2D py = position + diry;
-        Vector2D pxy = position + dirx + diry;
+		Vector2D position = Position;
+		Quaternion quaternion = Quaternion.ToQuaternion(Vector3D.Forward * RadianRotation);
+		Vector2D dirx = quaternion.GenerateDirectionRight() * SizeScale.x;
+		Vector2D diry = quaternion.GenerateDirectionDown() * SizeScale.y;
+		Vector2D pivx = quaternion.GenerateDirectionLeft() * PivotScale.x;
+		Vector2D pivy = quaternion.GenerateDirectionUp() * PivotScale.y;
+		position += pivx + pivy;
+		Vector2D px = position + dirx;
+		Vector2D py = position + diry;
+		Vector2D pxy = position + dirx + diry;
 
-        return IsPointInsideSquare(position, px, pxy, py, point);
-    }
+		return IsPointInsideSquare(position, px, pxy, py, point);
+	}
     /// <summary>Returns a <seealso cref="string"/> that represents the current <seealso cref="object"/> using the specified format and format provider.</summary>
     /// <param name="format">The format to use.</param>
     /// <param name="formatProvider">The provider to use to format the value.</param>
diff --git a/src/com.cobilas.godot.utility/build/Cobilas.Godot.Utility.props b/src/com.cobilas.godot.utility/build/Cobilas.Godot.Utility.props
index 7f2bcff..7f6ac22 100644
--- a/src/com.cobilas.godot.utility/build/Cobilas.Godot.Utility.props
+++ b/src/com.cobilas.godot.utility/build/Cobilas.Godot.Utility.props
@@ -1,6 +1,6 @@
 <Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
 	<PropertyGroup>
-		<ProjectVersion>7.5.0</ProjectVersion>
+		<ProjectVersion>7.5.1</ProjectVersion>
 		<PackageFolderPath>$(NuGetPackageRoot)cobilas.godot.utility</PackageFolderPath>
 		<CurrentPathPackageFolder>$(PackageFolderPath)\$(ProjectVersion)</CurrentPathPackageFolder>
 	</PropertyGroup>
diff --git a/test/Rect2D_Test.cs b/test/Rect2D_Test.cs
new file mode 100644
index 0000000..301b211
--- /dev/null
+++ b/test/Rect2D_Test.cs
@@ -0,0 +1,111 @@
+using Cobilas.GodotEngine.Utility;
+using Cobilas.GodotEngine.Utility.Input;
+using Cobilas.GodotEngine.Utility.Numerics;
+using Cobilas.GodotEngine.Utility.Runtime;
+using Godot;
+using System;
+
+public class Rect2D_Test : Camera2D
+{
+    [Export] private NodePath _label;
+	[Export] private NodePath _sprite;
+
+	[Export] private NodePath _panel;
+	[Export] private NodePath _offsetx;
+	[Export] private NodePath _offsety;
+	[Export] private NodePath _centeredT;
+
+	[Export] private Vector2 pivot;
+	[Export] private float rotation;
+
+	// Called when the node enters the scene tree for the first time.
+	public override void _Ready() {
+
+    }
+
+	public override void _Process(float delta) {
+		Vector2D s_offset = Vector2D.Zero;
+		Sprite sprite = GetNode<Sprite>(_sprite);
+		Label label = GetNode<Label>(_label);
+		Panel panel = GetNode<Panel>(_panel);
+
+		TextEdit offsetx = GetNode<TextEdit>(_offsetx),
+				 offsety = GetNode<TextEdit>(_offsety);
+		CheckButton centeredT = GetNode<CheckButton>(_centeredT);
+
+		sprite.Centered = centeredT.Pressed;
+
+		if (int.TryParse(offsetx.Text, out int offx))
+			s_offset.x = offx;
+		if (int.TryParse(offsety.Text, out int offy))
+			s_offset.y = offy;
+
+		sprite.Offset = s_offset;
+
+		Rect2D rectdd = new Rect2D(512f, 185f, 64f, 64f, 0f, 0f, rotation, 1f, 1f, 0f, 0f).SetPivot(pivot);
+		Rect2D rect = sprite.GetRect2D();
+		Rect2D prect = panel.GetRect2D();
+		Vector2D mpos = InputKeyBoard.MousePosition;
+		Vector2D pos = this.ScreenToWorldPoint(mpos);
+
+		if (InputKeyBoard.GetKeyPress(KeyCode.D))
+			Position += Vector2.Right * 35f * RunTime.DeltaTime;
+		if (InputKeyBoard.GetKeyPress(KeyCode.A))
+			Position += Vector2.Left * 35f * RunTime.DeltaTime;
+
+		DrawRect(rect);
+		DrawRect(rectdd);
+		DrawRect(Position);
+
+		label.ClearText()
+			.AppendLine($"Sprite-InRect : {rect.HasPoint(pos)}")
+			.AppendLine($"Panel-InRect : {prect.HasPoint(mpos)}")
+			.AppendLine($"rectdd-InRect : {rectdd.HasPoint(pos)}")
+			.AppendLine($"Mouse position : {mpos}")
+			.AppendLine($"Current resolution : {Screen.CurrentResolution}")
+			.AppendLine($"Zoom : {Zoom}")
+			.AppendLine($"Viewport rect : {base.GetViewportRect()}");
+
+		prect.SetPosition(this.ScreenToWorldPoint(prect.Position));
+		DrawRect(prect);
+	}
+
+	private void DrawRect(Vector2D pos) {
+
+		Gizmos.Color = Color.Color8(255, 0, 0);
+
+		Gizmos.DrawLine(pos, pos + Vector2D.Right * 5f);
+
+		Gizmos.Color = Color.Color8(0, 255, 0);
+
+		Gizmos.DrawLine(pos, pos + Vector2D.Up * 5f);
+	}
+
+	private void DrawRect(Rect2D rect) {
+		Gizmos.Color = Color.Color8(0, 0, 0);
+
+		Vector2D position = rect.Position;
+		Quaternion quaternion = Quaternion.ToQuaternion(Vector3D.Forward * rect.RadianRotation);
+		Vector2D dirx = quaternion.GenerateDirectionRight() * rect.SizeScale.x;
+		Vector2D diry = quaternion.GenerateDirectionDown() * rect.SizeScale.y;
+		Vector2D pivx = quaternion.GenerateDirectionLeft() * rect.PivotScale.x;
+		Vector2D pivy = quaternion.GenerateDirectionUp() * rect.PivotScale.y;
+		position += pivx + pivy;
+		Vector2D px = position + dirx;
+		Vector2D py = position + diry;
+		Vector2D pxy = position + dirx + diry;
+
+		Gizmos.DrawLine(position, px);
+		Gizmos.DrawLine(position, py);
+		Gizmos.DrawLine(px, pxy);
+		Gizmos.DrawLine(py, pxy);
+
+		Gizmos.Color = Color.Color8(255, 0, 0);
+
+		Gizmos.DrawLine(rect.Position, rect.Position + Vector2D.Right * 5f);
+
+		Gizmos.Color = Color.Color8(0, 255, 0);
+
+		Gizmos.DrawLine(rect.Position, rect.Position + Vector2D.Up * 5f);
+	}
+}
diff --git a/test/Scenes/Rect2D_Test.tscn b/test/Scenes/Rect2D_Test.tscn
new file mode 100644
index 0000000..9ff31e9
--- /dev/null
+++ b/test/Scenes/Rect2D_Test.tscn
@@ -0,0 +1,72 @@
+[gd_scene load_steps=3 format=2]
+
+[ext_resource path="res://icon.png" type="Texture" id=1]
+[ext_resource path="res://Rect2D_Test.cs" type="Script" id=2]
+
+[node name="Rect2D_Test" type="Node2D"]
+
+[node name="Camera2D" type="Camera2D" parent="."]
+position = Vector2( 512, 300 )
+current = true
+script = ExtResource( 2 )
+_label = NodePath("../CanvasLayer/Label")
+_sprite = NodePath("../Sprite")
+_panel = NodePath("../CanvasLayer/Panel")
+_offsetx = NodePath("../CanvasLayer/Panel/offset_x")
+_offsety = NodePath("../CanvasLayer/Panel/offset_y")
+_centeredT = NodePath("../CanvasLayer/Panel/s_centered")
+
+[node name="Sprite" type="Sprite" parent="."]
+position = Vector2( 557, 301 )
+texture = ExtResource( 1 )
+
+[node name="CanvasLayer" type="CanvasLayer" parent="."]
+
+[node name="Label" type="Label" parent="CanvasLayer"]
+margin_right = 367.0
+margin_bottom = 195.0
+
+[node name="Panel" type="Panel" parent="CanvasLayer"]
+self_modulate = Color( 1, 1, 1, 0.160784 )
+margin_left = 774.0
+margin_top = 25.0
+margin_right = 1024.0
+margin_bottom = 150.0
+rect_pivot_offset = Vector2( 125, 0 )
+
+[node name="l_offset_x" type="Label" parent="CanvasLayer/Panel"]
+margin_right = 70.0
+margin_bottom = 25.0
+text = "OffSet X"
+valign = 1
+
+[node name="l_offset_y" type="Label" parent="CanvasLayer/Panel"]
+margin_top = 25.0
+margin_right = 70.0
+margin_bottom = 50.0
+text = "OffSet Y"
+valign = 1
+
+[node name="offset_x" type="TextEdit" parent="CanvasLayer/Panel"]
+anchor_left = 1.0
+anchor_right = 1.0
+margin_left = -180.0
+margin_bottom = 25.0
+text = "0"
+bookmark_gutter = true
+
+[node name="offset_y" type="TextEdit" parent="CanvasLayer/Panel"]
+anchor_left = 1.0
+anchor_right = 1.0
+margin_left = -180.0
+margin_top = 25.0
+margin_bottom = 50.0
+text = "0"
+bookmark_gutter = true
+
+[node name="s_centered" type="CheckButton" parent="CanvasLayer/Panel"]
+margin_top = 50.0
+margin_right = 250.0
+margin_bottom = 90.0
+pressed = true
+text = "Centered"
diff --git a/test/godot.test.csproj b/test/godot.test.csproj
index 37312fd..23b12f9 100644
--- a/test/godot.test.csproj
+++ b/test/godot.test.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Godot.NET.Sdk/3.3.0">
+ï»¿<Project Sdk="Godot.NET.Sdk/3.3.0">
   <PropertyGroup>
     <TargetFramework>net472</TargetFramework>
     <Configurations>Debug;ExportDebug;ExportRelease;Release</Configurations>
@@ -19,6 +19,6 @@
     <Content Include="TextFile1.txt" />
   </ItemGroup>
   <ItemGroup>
-    <PackageReference Include="Cobilas.Godot.Utility" Version="7.4.1" />
+    <PackageReference Include="Cobilas.Godot.Utility" Version="7.5.1" />
   </ItemGroup>
 </Project>
\ No newline at end of file
diff --git a/test/icon.png b/test/icon.png
new file mode 100644
index 0000000..e032a97
Binary files /dev/null and b/test/icon.png differ
diff --git a/test/icon.png.import b/test/icon.png.import
new file mode 100644
index 0000000..a4c02e6
--- /dev/null
+++ b/test/icon.png.import
@@ -0,0 +1,35 @@
+[remap]
+
+importer="texture"
+type="StreamTexture"
+path="res://.import/icon.png-487276ed1e3a0c39cad0279d744ee560.stex"
+metadata={
+"vram_texture": false
+}
+
+[deps]
+
+source_file="res://icon.png"
+dest_files=[ "res://.import/icon.png-487276ed1e3a0c39cad0279d744ee560.stex" ]
+
+[params]
+
+compress/mode=0
+compress/lossy_quality=0.7
+compress/hdr_mode=0
+compress/bptc_ldr=0
+compress/normal_map=0
+flags/repeat=0
+flags/filter=true
+flags/mipmaps=false
+flags/anisotropic=false
+flags/srgb=2
+process/fix_alpha_border=true
+process/premult_alpha=false
+process/HDR_as_SRGB=false
+process/invert_color=false
+process/normal_map_invert_y=false
+stream=false
+size_limit=0
+detect_3d=true
+svg/scale=1.0
diff --git a/test/project.godot b/test/project.godot
index e412653..b080c83 100644
--- a/test/project.godot
+++ b/test/project.godot
@@ -11,7 +11,7 @@ config_version=4
 [application]
 
 config/name="godot.test"
-run/main_scene="res://Scenes/Node_Test.tscn"
+run/main_scene="res://Scenes/Rect2D_Test.tscn"
 
 [autoload]
 
